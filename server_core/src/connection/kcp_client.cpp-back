#include <cstdlib>
#include <functional>
#include "kcp_client.h"
#include "mobile_client.h"

static const unsigned int CONN_REQ_LEN = 16;
static const char CONN_REQ_SYNC = 'S';
static const char CONN_REQ_ACK = 'A';

KcpClient::KcpClient(boost::asio::io_service& io_service, uint32_t port)
    : KcpConnection(io_service),
      conn_timer_(io_service)
{
    boost::asio::ip::address addr;
    addr.from_string("127.0.0.1");
    rmt_addr_ = udp_addr(addr, port);

    std::cout << "Create KcpClient\n";
}

void KcpClient::asyncConnect()
{
    if (state_ == State::state_conning)
    {
        return;
    }

    last_recv_ = last_send_ = stamp_millisecond();

    doConnect();
    conn_timer_.expires_from_now(boost::posix_time::seconds(6));
    // TODO...需要使用strand包裹
    conn_timer_.async_wait(std::bind(&KcpClient::onConnectTimeout,
                                     std::static_pointer_cast<KcpClient>(shared_from_this()),
                                     std::placeholders::_1));
}

void KcpClient::onConnected(bool connected)
{
    DEBUG_LOG << "KcpClient onConnected: " << connected;
    if (connected)
    {
        DEBUG_LOG << "KcpClient cancel conn_timer";
        conn_timer_.cancel();
        createKcp();
        startKcpUpdate();
    }

    if (connect_cb_)
    {
        connect_cb_(connected);
    }
}

void KcpClient::onDisconnected()
{
    INFO_LOG << "KcpClient::on_disconnected ";
    if (disconnect_cb_)
    {
        disconnect_cb_();
    }
}

void KcpClient::handleCloseSocket()
{
    cancelKcpUpdate();
    conn_timer_.cancel();
    onDisconnected();
}

void KcpClient::doConnect()
{
    conn_cnt_ ++;
    state_ = State::state_conning;
    boost_err ec;
    socket_.connect(rmt_addr_, ec);
    if (ec)
    {
        onConnected(false);
        return;
    }

    // TODO...为了避免丢包，可启动定时器重复发送Sync/Ack
    socket_.send(boost::asio::buffer(&CONN_REQ_SYNC, 1), 0, ec);
    if (ec)
    {
        onConnected(false);
        return;
    }
    asyncReceiveSync();
}

void KcpClient::onConnectTimeout(const boost_err& ec)
{
    if (ec == boost::asio::error::operation_aborted)
    {
        return;
    }
    if (state_ == State::state_conning)
    {
        state_ = State::state_failed;
        onConnected(false);
    }
}

void KcpClient::handleReceiveSync(const boost_err& ec, std::size_t bytes)
{
    // TODO...过于粗暴，很有细节需要处理
    if (state_ == State::state_conning)
    {
        char *buf = recv_buffer_.data();
        if (CONN_REQ_LEN == bytes && CONN_REQ_SYNC == buf[0])
        {
            DEBUG_LOG << "KcpClient rece server Sync";
            buf[0] = CONN_REQ_ACK;
            syncSend(buf, CONN_REQ_LEN);
            asyncReceiveSync();
            return;
        }
        if (1 == bytes && CONN_REQ_ACK == buf[0])
        {
            DEBUG_LOG << "KcpClient rece server Ack";
            onConnected(true);
            asyncReceive();
            return;
        }
    }
}


