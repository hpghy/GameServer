#ifndef KCP_CLIENT_HPP_
#define KCP_CLIENT_HPP_

#include <boost/asio.hpp>
#include <boost/bind.hpp>
#include <boost/date_time/posix_time/posix_time.hpp>
#include "../connection/kcp_connection.h"


class MobileClient;
class KcpClient: public KcpConnection
{
public:
	KcpClient(boost::asio::io_service&, uint32_t);

	void asyncConnect();
	void onConnected(bool);
	void onDisconnected();
	virtual void handleReceiveSync(const boost_err&, std::size_t);

	void setConnectCallback(function<void(bool)> connect_cb)
	{
		connect_cb_ = connect_cb;
	}
    void setDisconnectCallback(function<void()> disconnect_cb)
    {
        disconnect_cb_ = disconnect_cb;
    }

	enum class State {
		state_init = 0,
		state_conning,
		state_failed,
		state_success,
	};

	virtual void handleCloseSocket();

private:
	void doConnect();
	void doConnectTimeout(const boost_err&);
	void asyncReceiveSync()
	{
		//避免async operation触发多个completion handler
		socket_.async_receive(boost::asio::buffer(recv_buffer_),
			rcv_strand_->wrap(boost::bind(&KcpClient::handleReceiveSync,
										this,
										boost::asio::placeholders::error,
										boost::asio::placeholders::bytes_transferred)));
	}

	void onConnectTimeout(const boost_err&);
	void testSend(const boost_err&);
	void doTestSend();

private:
	boost::asio::deadline_timer		conn_timer_;
	unsigned int 	conn_cnt_ = 0;
	State 	        state_ = State::state_init;
    function<void(bool)> connect_cb_;
    function<void()> disconnect_cb_;
};
using KcpClientPtr = std::shared_ptr<KcpClient>;

#endif

